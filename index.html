<!doctype html>
<html class="no-js" lang="">

<head>
  <meta charset="utf-8">
  <title>Screenio</title>
  <meta name="description" content="Compare how different screen sizes and PPI compares to eachother">
  <meta name="viewport" content="width=device-width, initial-scale=1">

  <meta name="theme-color" content="#fafafa">
</head>

<body>
  <div class="display-selector-js">
    <input type="range" min="0.5" max="100" step="0.5" value="32">
    <select>
      <option value="6016x3384">6016x3384px</option>
      <option value="5120x2880">5120x2880px</option>
      <option value="5120x1440">5120x1440px</option>
      <option value="3840x2160">3840x2160px</option>
      <option value="3440x1440">3440x1440px</option>
      <option value="2560x1600">2560x1600px</option>
      <option value="2560x1440" selected>2560x1440px</option>
      <option value="2560x1080">2560x1080px</option>
      <option value="1920x1200">1920x1200px</option>
      <option value="1920x1080">1920x1080px</option>
      <option value="1280x1024">1280x1024px</option>
      <option value="1024x768">1024x768px</option>
    </select>
  </div>
  <div class="display-selector-js">
    <input type="range" min="0.5" max="100" step="0.5" value="24">
    <select>
      <option value="6016x3384">6016x3384px</option>
      <option value="5120x2880">5120x2880px</option>
      <option value="5120x1440">5120x1440px</option>
      <option value="3840x2160">3840x2160px</option>
      <option value="3440x1440">3440x1440px</option>
      <option value="2560x1600">2560x1600px</option>
      <option value="2560x1440">2560x1440px</option>
      <option value="2560x1080">2560x1080px</option>
      <option value="1920x1200">1920x1200px</option>
      <option value="1920x1080" selected>1920x1080px</option>
      <option value="1280x1024">1280x1024px</option>
      <option value="1024x768">1024x768px</option>
    </select>
  </div>
  <svg id="render" width="70%" style="margin: 2rem">
  </svg>
  <p id="explanation"></p>
  <pre id="output"></pre>
  <script>

    const physicalScale = 100;
    const chromeRadius = 25;

    /*
     * Calculates the PPI and scaled size of a size:resolution combo.
     */
    function getDisplayScaleProperties(input) {
      const resolutionPxHypothenuse = Math.sqrt(Math.pow(input.resolutionPx.height, 2) + Math.pow(input.resolutionPx.width, 2));
      const ppi = resolutionPxHypothenuse / input.physicalIn.hypothenuse;
      const width = Math.round(input.resolutionPx.width / ppi * physicalScale);
      const height = Math.round(input.resolutionPx.height / ppi * physicalScale);
      return {
        ppi,
        scaledPx: {
          width,
          height,
          area: width * height
        }
      }
    }

    function getDisplayFromGroup(g) {
      const resolution = g.querySelector('select').value;
      const width = resolution.substring(0, resolution.indexOf('x'));
      const height = resolution.substring(resolution.indexOf('x') + 1);
      return {
        physicalIn: {
          hypothenuse: g.querySelector('input[type="range"]').value
        },
        resolutionPx: {
          width,
          height,
          area: width * height
        }
      };
    }

    function getRenderSize(displays) {
      return {
        width: Math.max(...displays.map(x => x.scaledPx.width)),
        height: Math.max(...displays.map(x => x.scaledPx.height))
      }
    }

    function getRelativeObjectResolutionSizeSize(displays) {
      const leastResolutionHeight = Math.min(...displays.map(x => x.resolutionPx.height));
      // Assume that a displays width is always greater than its height
      return {
        height: leastResolutionHeight / 3
      };
    }

    function renderDisplay(display, color, renderSize) {
      const g = document.createElementNS('http://www.w3.org/2000/svg', "g");
      g.setAttribute('fill', color);

      const chrome = document.createElementNS('http://www.w3.org/2000/svg', "path");
      const h = display.scaledPx.height;
      const w = display.scaledPx.width;
      const r = chromeRadius;
      // originX gets an extra "+ r" as we need to make room for the closing q.
      const originX = ((renderSize.width - display.scaledPx.width) / 2) + r;
      const originY = ((renderSize.height - display.scaledPx.height) / 2);
      chrome.setAttribute('d', `
      M${originX} ${originY}
      l ${w} 0
      q ${r},0 ${r},${r}
      l0 ${h}
      q 0,${r} -${r},${r}
      l-${w} 0
      q -${r},0 -${r},-${r}
      l0 -${h}
      q0,-${r} ${r},-${r}`);
      chrome.style = 'opacity: 1; fill: #3f3d56';

      const rect = document.createElementNS('http://www.w3.org/2000/svg', "rect");
      rect.setAttribute('width', display.scaledPx.width);
      rect.setAttribute('height', display.scaledPx.height);
      rect.setAttribute('x', ((renderSize.width - display.scaledPx.width) / 2) + r);
      rect.setAttribute('y', ((renderSize.height - display.scaledPx.height) / 2) + r);
      rect.style = 'opacity: 0.5';


      g.appendChild(chrome);
      g.appendChild(rect);

      return g;
    }

    function renderRelativeObject(displayRelativeObjectSize, color) {
      const relativeObject = document.createElementNS('http://www.w3.org/2000/svg', "text");
      relativeObject.innerHTML = 'A';
      relativeObject.setAttribute('x', '50%');
      relativeObject.setAttribute('y', '50%');
      relativeObject.setAttribute('dominant-baseline', 'middle');
      relativeObject.setAttribute('text-anchor', 'middle');
      relativeObject.style = `fill: ${color}; font-size: ${displayRelativeObjectSize}px`;

      return relativeObject;
    }

    function renderDisplays(displaySelectGroups, svg, output) {
      // Calculate the properties for the listed displays
      const displaysByPhysicalArea = displaySelectGroups
        .map(g => getDisplayFromGroup(g))
        .map((x, i) => ({
          name: i + 1,
          ...getDisplayScaleProperties(x),
          ...x
        }))
        // It might be better to sort based on height,
        // initial thought is that it might feel better in the case of ultrawides (which is often sent to the back with the current sort)
        .sort((a, b) => b.scaledPx.area - a.scaledPx.area);

      // Output the calculated display properties for debug purposes
      output.innerHTML = JSON.stringify(displaysByPhysicalArea, null, 2);

      // Set the render size of the svg
      const renderSize = getRenderSize(displaysByPhysicalArea);
      const unScaledRelativeObjectSize = getRelativeObjectResolutionSizeSize(displaysByPhysicalArea);

      // Clear the render svg
      svg.innerHTML = '';
      svg.setAttribute('viewBox', `0 0 ${renderSize.width + (2 * chromeRadius)} ${renderSize.height + (2 * chromeRadius)}`);

      displaysByPhysicalArea.forEach((display, i) => {
        svg.appendChild(renderDisplay(display, colors[i], renderSize));
      });

      const displaysByRelativeSize = displaysByPhysicalArea.map((x, i) => ({
        ppi: x.ppi,
        color: colors[i],
        scaledRelativeObjectSize: unScaledRelativeObjectSize.height / x.ppi * physicalScale
      }))
        .sort((a, b) => b.scaledRelativeObjectSize - a.scaledRelativeObjectSize);

      displaysByRelativeSize.forEach(display => {
        svg.appendChild(renderRelativeObject(display.scaledRelativeObjectSize, display.color));
      });

      // TODO: Verify the differences as we're always calculating from higher > lower, but text mentions smaller/larger
      const relativeDifference = Math.round(displaysByRelativeSize[0].scaledRelativeObjectSize / displaysByRelativeSize[1].scaledRelativeObjectSize * 100 - 100);
      const physicalDifference = Math.round(displaysByPhysicalArea[0].scaledPx.area / displaysByPhysicalArea[1].scaledPx.area * 100 - 100);
      const resolutionDifference = Math.round(displaysByPhysicalArea[0].resolutionPx.area / displaysByPhysicalArea[1].resolutionPx.area * 100 - 100);

      const d1 = displaysByPhysicalArea[0].name;
      const d2 = displaysByPhysicalArea[1].name;

      let ex = '';
      if (physicalDifference == 0 && resolutionDifference == 0) ex = 'These displays are of equal size and has the same resolution area.';
      else if (physicalDifference == 0 && resolutionDifference > 0) ex = `Display ${d1} will fit ${resolutionDifference}% more content than display ${d2}, but objects will appear ${relativeDifference}% smaller, even though the displays are the same physical size.`;
      else if (physicalDifference == 0 && resolutionDifference < 0) ex = `Display ${d1} will fit ${Math.abs(resolutionDifference)}% less content than display ${d2} , and objects will appear ${relativeDifference}% larger, even though the displays are the same physical size.`;
      else if (physicalDifference > 0 && resolutionDifference == 0) ex = `Display ${d1} will fit the same amount of content as display ${d2}, but objects will be ${relativeDifference}% larger due to display ${d1}'s ${physicalDifference}% larger physical size.`;
      else if (physicalDifference > 0 && resolutionDifference > 0 && relativeDifference == 0) ex = `Display ${d1} will fit ${resolutionDifference}% more content than display ${d2}, but objects will have the same size due to display ${d1}'s ${physicalDifference}% larger physical size.`;
      else if (physicalDifference > 0 && resolutionDifference > 0 && relativeDifference > 0) ex = `Display ${d1} is ${physicalDifference}% larger than display ${d2}, and will fit ${resolutionDifference}% more content, but objects will appear smaller due to display ${d1}'s higher ppi.`;
      else if (physicalDifference > 0 && resolutionDifference > 0 && relativeDifference < 0) ex = `Display ${d1} is ${physicalDifference}% larger than display ${d2} and will fit ${resolutionDifference}% more content, but objects will appear ${Math.abs(relativeDifference)}% bigger due to display x's lower ppi.`;
      else if (physicalDifference > 0 && resolutionDifference < 0) ex = `Display ${d1} is ${physicalDifference}% larger than display ${d2}, but will fit ${Math.abs(resolutionDifference)}% less content. Objects will appear larger on display ${d1} than on display ${d2} due to display ${d1}'s lower ppi.`;
      
      document.getElementById('explanation').innerHTML = ex;
    }

    const colors = [
      'red',
      'blue',
      'green',
      'yellow'
    ];

    const selectorGroups = Array.from(document.getElementsByClassName('display-selector-js'));

    const output = document.getElementById('output');
    const svg = document.getElementById('render');

    renderDisplays(selectorGroups, svg, output);

    selectorGroups
      .map(g => Array.from(g.querySelectorAll('input[type="range"], select')))
      .reduce((a, c) => [...c, ...a], [])
      .forEach(displaySelect => {
        displaySelect.addEventListener('input', () => renderDisplays(selectorGroups, svg, output));
      });

  </script>
</body>

</html>